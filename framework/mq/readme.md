## 说明

### 整体说明

这个项目准备仿照rabbitmq模拟一个粗糙的mq工具出来。准备提供go和php两个版本的，用redis和mysql进行存储。

这个mq工具主要是给体量不需要正儿八经的mq的项目使用的。不想引入rabbitmq或者kafka增加项目复杂度的也可以试试。

先整golang版本和redis存储，然后增加mysql存储，最后再整一个php版本的出来。redis和mysql只用最简单的数据结构。

比如说，mq的发布订阅模式，不会使用redis的发布订阅功能，而是用list、set、string这几个简单的结构去模拟。

选择用redis和mysql进行存储只因为这两个组件是最常用的组件。只用最简单的数据结构的原因是，让整个工具最大限度的保持可控。

### 功能设计

现阶段提供三种消息队列模式，普通模式、发布订阅模式、确认模式。

普通模式，发布者发送消息到消息队列，订阅者从消息队列中取走消息。
普通模式的消息不考虑顺序。消息队列中的消息取走就取走了，订阅者处理成功也好失败也罢，不管。

发布订阅模式，需要在发布者、频道、订阅者之间维护一组关系。每当发布者在一个频道上发布消息时，每个订阅这个频道的订阅者都会收到消息。
发布订阅模式的消息不考虑顺序。每个订阅者的消息队列中的消息取走就取走了，订阅者处理成功也好失败也罢，不管。

发布订阅模式这里有一个问题，如果有多个发布者在同一个频道上并发发布消息，那么每个订阅者收到的消息的顺序需不需要保持一致。现阶段这里没有保证一致。

确认模式，发布者发送消息到消息队列，订阅者从消息队列中取走消息。
确认模式的消息不考虑顺序。但是消息队列中的被取走之后，必须要保证消息被正确消费。

### redis 存储实现

#### 普通模式

普通模式的 MQ 用 list 实现。主要使用 RPush 和 LPop。逻辑非常的简单。

#### 发布订阅模式

发布订阅模式的 MQ 用 list、set、string 实现。首先订阅者需要订阅频道，这里用set实现。
然后，发布者利用这个set找到所有的订阅者，并发送消息。每个订阅者的消息队列就是个普通模式的 MQ。

这里还需要维持一个心跳机制，发布者需要知道订阅者还在消费消息。要不然发布者一直给死了的订阅者发消息，这消息又没有被处理，会造成资源泄露的。

这里的设计是，订阅者定期向一个string里面写入数据，这样发布者就可以知道自己还活着。
发布者每次发消息的时候都会检查一下订阅者的状态，如果发现订阅者死了很久了，就会把这个订阅者注销掉，并释放这个订阅者占用的全部资源。

#### 确认模式

确认模式的 MQ 用 list、string、lua 实现。消息队列本体就是个普通模式的 MQ，然后，加上其他的机制保证消息会被正确消费。
