package main

import "fmt"

func main() {
  // fmt.Println(numIslands([][]byte{
  //   {'1', '1', '0', '0', '0'},
  //   {'1', '1', '0', '0', '0'},
  //   {'0', '0', '1', '0', '0'},
  //   {'0', '0', '0', '1', '1'},
  // }))

  // fmt.Println(numIslands([][]byte{
  //   {'1', '1', '1'},
  //   {'0', '1', '0'},
  //   {'1', '1', '1'},
  // }))

  fmt.Println(numIslands([][]byte{
    {'1', '1', '1', '1', '1', '0', '1', '1', '1', '1', '1', '1', '1', '1', '1', '0', '1', '0', '1', '1'},
    {'0', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '0', '1', '1', '1', '1', '1', '0'},
    {'1', '0', '1', '1', '1', '0', '0', '1', '1', '0', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1'},
    {'1', '1', '1', '1', '0', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1'},
    {'1', '0', '0', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1'},
    {'1', '0', '1', '1', '1', '1', '1', '1', '0', '1', '1', '1', '0', '1', '1', '1', '0', '1', '1', '1'},
    {'0', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '0', '1', '1', '0', '1', '1', '1', '1'},
    {'1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '0', '1', '1', '1', '1', '0', '1', '1'},
    {'1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '0', '1', '1', '1', '1', '1', '1', '1', '1', '1'},
    {'1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1'},
    {'0', '1', '1', '1', '1', '1', '1', '1', '0', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1'},
    {'1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1'},
    {'1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1'},
    {'1', '1', '1', '1', '1', '0', '1', '1', '1', '1', '1', '1', '1', '0', '1', '1', '1', '1', '1', '1'},
    {'1', '0', '1', '1', '1', '1', '1', '0', '1', '1', '1', '0', '1', '1', '1', '1', '0', '1', '1', '1'},
    {'1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '0', '1', '1', '1', '1', '1', '1', '0'},
    {'1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '0', '1', '1', '1', '1', '0', '0'},
    {'1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1'},
    {'1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1'},
    {'1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1'},
  }))
}

//给你一个由'1'（陆地）和'0'（水）组成的的二维网格，请你计算网格中岛屿的数量。
//岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。
//此外，你可以假设该网格的四条边均被水包围。
//m==grid.length;n==grid[i].length;1<=m,n<=300;grid[i][j]的值为'0'或'1'

//数组，广度优先搜索，队列
//类似广度优先搜索，遍历二维数组，如果找到陆地，标记为访问过，然后入队。
//如果队列不为空，就出队，在访问位置，检查上右下左四个方向。
//如果是陆地，标记为访问过，然后入队。直到访问队列为空，本次搜索结束，岛屿数量加1。
//继续遍历二维数组，直到所有的位置都访问过一次。

//200-岛屿数量(200,695,733)
func numIslands(grid [][]byte) int {
  var hang2, lie4 int = len(grid), len(grid[0]) //二维数组行列数
  var land, visited byte = '1', '2'             //陆地，访问过的陆地
  var queue [][2]int                            //队列
  var queueStart, queueEnd int = 0, 0           //队列下标
  var islandNum int = 0

  for hang2Index := 0; hang2Index < hang2; hang2Index++ {
    for lie4Index := 0; lie4Index < lie4; lie4Index++ {
      if grid[hang2Index][lie4Index] == land {
        //类似广度优先搜索
        grid[hang2Index][lie4Index] = visited //标记陆地已访问
        queue = append(queue, [2]int{hang2Index, lie4Index})
        queueEnd++
        for queueStart < queueEnd {
          hang2Temp, lie4Temp := queue[queueStart][0], queue[queueStart][1]
          queueStart++
          //检查上右下左四个方向
          if hang2Temp-1 >= 0 && grid[hang2Temp-1][lie4Temp] == land {
            grid[hang2Temp-1][lie4Temp] = visited
            queue = append(queue, [2]int{hang2Temp - 1, lie4Temp})
            queueEnd++
          }
          if lie4Temp+1 < lie4 && grid[hang2Temp][lie4Temp+1] == land {
            grid[hang2Temp][lie4Temp+1] = visited
            queue = append(queue, [2]int{hang2Temp, lie4Temp + 1})
            queueEnd++
          }
          if hang2Temp+1 < hang2 && grid[hang2Temp+1][lie4Temp] == land {
            grid[hang2Temp+1][lie4Temp] = visited
            queue = append(queue, [2]int{hang2Temp + 1, lie4Temp})
            queueEnd++
          }
          if lie4Temp-1 >= 0 && grid[hang2Temp][lie4Temp-1] == land {
            grid[hang2Temp][lie4Temp-1] = visited
            queue = append(queue, [2]int{hang2Temp, lie4Temp - 1})
            queueEnd++
          }
        }
        islandNum++ //相连的陆地已经全部标记，岛屿数量加1
      }
    }
  }

  return islandNum
}
