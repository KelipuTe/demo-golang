package main

import "fmt"

func main() {
  // fmt.Println(numIslands([][]byte{
  //   {'1', '1', '0', '0', '0'},
  //   {'1', '1', '0', '0', '0'},
  //   {'0', '0', '1', '0', '0'},
  //   {'0', '0', '0', '1', '1'},
  // }))

  // fmt.Println(numIslands([][]byte{
  //   {'1', '1', '1'},
  //   {'0', '1', '0'},
  //   {'1', '1', '1'},
  // }))

  fmt.Println(numIslands([][]byte{
    {'1', '1', '1', '1', '1', '0', '1', '1', '1', '1', '1', '1', '1', '1', '1', '0', '1', '0', '1', '1'},
    {'0', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '0', '1', '1', '1', '1', '1', '0'},
    {'1', '0', '1', '1', '1', '0', '0', '1', '1', '0', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1'},
    {'1', '1', '1', '1', '0', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1'},
    {'1', '0', '0', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1'},
    {'1', '0', '1', '1', '1', '1', '1', '1', '0', '1', '1', '1', '0', '1', '1', '1', '0', '1', '1', '1'},
    {'0', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '0', '1', '1', '0', '1', '1', '1', '1'},
    {'1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '0', '1', '1', '1', '1', '0', '1', '1'},
    {'1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '0', '1', '1', '1', '1', '1', '1', '1', '1', '1'},
    {'1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1'},
    {'0', '1', '1', '1', '1', '1', '1', '1', '0', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1'},
    {'1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1'},
    {'1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1'},
    {'1', '1', '1', '1', '1', '0', '1', '1', '1', '1', '1', '1', '1', '0', '1', '1', '1', '1', '1', '1'},
    {'1', '0', '1', '1', '1', '1', '1', '0', '1', '1', '1', '0', '1', '1', '1', '1', '0', '1', '1', '1'},
    {'1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '0', '1', '1', '1', '1', '1', '1', '0'},
    {'1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '0', '1', '1', '1', '1', '0', '0'},
    {'1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1'},
    {'1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1'},
    {'1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1'},
  }))
}

//给你一个由'1'（陆地）和'0'（水）组成的的二维网格，请你计算网格中岛屿的数量。
//岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。
//此外，你可以假设该网格的四条边均被水包围。
//m==grid.length;n==grid[i].length;1<=m,n<=300;grid[i][j]的值为'0'或'1'

//广度优先遍历，队列
//类似广度优先遍历，首先遍历二维数组，
//如果找到陆地，先标记为访问过，比如'2'，然后入队。
//如果队列不为空，就持续出队，从这个访问过的位置，检查上右下左四个方向是不是陆地，
//如果是陆地，先标记为访问过，然后入队。
//直到访问不到陆地，本次队列结束，岛屿数量加1

//200-岛屿数量
func numIslands(grid [][]byte) int {
  var iHang2Len, iLie4Len int           //二维数组行列数
  var queue [][2]int                    //队列
  var iStartIndex, iEndIndex int = 0, 0 //队列下标
  var iIslandNum int = 0

  iHang2Len = len(grid)
  iLie4Len = len(grid[0])

  for iHang2Now := 0; iHang2Now < iHang2Len; iHang2Now++ {
    for iLie4Now := 0; iLie4Now < iLie4Len; iLie4Now++ {
      if grid[iHang2Now][iLie4Now] == '1' {
        //类似广度优先遍历，找到和这个陆地连接的所有的陆地
        grid[iHang2Now][iLie4Now] = '2' //标记陆地已访问
        queue = append(queue, [2]int{iHang2Now, iLie4Now})
        iEndIndex++
        for iStartIndex < iEndIndex {
          tHang2, tLie4 := queue[iStartIndex][0], queue[iStartIndex][1]
          iStartIndex++
          //检查上右下左四个方向是不是陆地，是陆地就入队
          if tHang2-1 >= 0 && grid[tHang2-1][tLie4] == '1' {
            grid[tHang2-1][tLie4] = '2'
            queue = append(queue, [2]int{tHang2 - 1, tLie4})
            iEndIndex++
          }
          if tLie4+1 < iLie4Len && grid[tHang2][tLie4+1] == '1' {
            grid[tHang2][tLie4+1] = '2'
            queue = append(queue, [2]int{tHang2, tLie4 + 1})
            iEndIndex++
          }
          if tHang2+1 < iHang2Len && grid[tHang2+1][tLie4] == '1' {
            grid[tHang2+1][tLie4] = '2'
            queue = append(queue, [2]int{tHang2 + 1, tLie4})
            iEndIndex++
          }
          if tLie4-1 >= 0 && grid[tHang2][tLie4-1] == '1' {
            grid[tHang2][tLie4-1] = '2'
            queue = append(queue, [2]int{tHang2, tLie4 - 1})
            iEndIndex++
          }
        }
        iIslandNum++ //相连的陆地已经全部标记，岛屿数量加1
      }
    }
  }

  return iIslandNum
}
