package main

import "fmt"

func main() {
  fmt.Println(isValidSudoku([][]byte{
    {'5', '3', '.', '.', '7', '.', '.', '.', '.'},
    {'6', '.', '.', '1', '9', '5', '.', '.', '.'},
    {'.', '9', '8', '.', '.', '.', '.', '6', '.'},
    {'8', '.', '.', '.', '6', '.', '.', '.', '3'},
    {'4', '.', '.', '8', '.', '3', '.', '.', '1'},
    {'7', '.', '.', '.', '2', '.', '.', '.', '6'},
    {'.', '6', '.', '.', '.', '.', '2', '8', '.'},
    {'.', '.', '.', '4', '1', '9', '.', '.', '5'},
    {'.', '.', '.', '.', '8', '.', '.', '7', '9'},
  }))
  fmt.Println(isValidSudoku([][]byte{
    {'8', '3', '.', '.', '7', '.', '.', '.', '.'},
    {'6', '.', '.', '1', '9', '5', '.', '.', '.'},
    {'.', '9', '8', '.', '.', '.', '.', '6', '.'},
    {'8', '.', '.', '.', '6', '.', '.', '.', '3'},
    {'4', '.', '.', '8', '.', '3', '.', '.', '1'},
    {'7', '.', '.', '.', '2', '.', '.', '.', '6'},
    {'.', '6', '.', '.', '.', '.', '2', '8', '.'},
    {'.', '.', '.', '4', '1', '9', '.', '.', '5'},
    {'.', '.', '.', '.', '8', '.', '.', '7', '9'},
  }))
}

//请判断一个9x9的数独是否有效。
//只需要根据以下规则，验证已经填入的数字是否有效即可。
//数字1-9在每一行只能出现一次。数字1-9在每一列只能出现一次。
//数字1-9在每一个以粗实线分隔的3x3宫内只能出现一次。（请参考示例图）
//数独部分空格内已填入了数字，空白格用'.'表示。
//一个有效的数独（部分已被填充）不一定是可解的。
//只需要根据以上规则，验证已经填入的数字是否有效即可。
//board.length==9;board[i].length==9;board[i][j]是一位数字或者'.'

//数组
//用三个9行9列的数组存储，每行每列每个宫格中，是否1-9出现过。
//行的下标，列的下标，宫格的下标都是从0-8，宫格的下标计算方式是：(行/3)*3+(列/3)
//字符1的数值是49，想要把数字字符变成下标就-49。

//36-有效的数独
func isValidSudoku(board [][]byte) bool {
  var arr2hang2, arr2lie4, arr2gong1 [9][9]int = [9][9]int{}, [9][9]int{}, [9][9]int{}

  for indexi := 0; indexi < 9; indexi++ {
    for indexj := 0; indexj < 9; indexj++ {
      if board[indexi][indexj] != '.' {
        num := board[indexi][indexj] - 49
        //判断行
        if arr2hang2[indexi][num] != 1 {
          arr2hang2[indexi][num] = 1
        } else {
          return false
        }
        //判断列
        if arr2lie4[indexj][num] != 1 {
          arr2lie4[indexj][num] = 1
        } else {
          return false
        }
        //判断宫格
        gong1 := (indexi/3)*3 + (indexj / 3)
        if arr2gong1[gong1][num] != 1 {
          arr2gong1[gong1][num] = 1
        } else {
          return false
        }
      }
    }
  }

  return true
}
