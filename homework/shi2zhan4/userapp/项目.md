毕业项目

按照毕设项目的目标，所有的组件都自行实现的话效果是最好的。但是这样的工作量怎么看都不是一周能写完的东西。
所以这篇文档是按照毕设项目的要求写的设计文档。整体实现只能在时间充足的时候再去实践。

首先手上已经大概写好的框架demo有:

- web框架：https://github.com/KelipuTe/web-framework-go/v40
- orm框架：https://github.com/KelipuTe/orm-go/v20
- 缓存：https://github.com/KelipuTe/cache-go/v20

下面针对毕业设计的每个要求先写好大概的实现思路。

> 利用微服务框架部分的服务治理原理，为 userapp 提供熔断、限流、降级的功能。（单体应用一样需要治理）。其中限流要做到在整个集群（也就是 userapp 部署多个实例）上，每一个 IP（要小心网关）一秒钟只能有三个登录请求

这个要求比较好实现，实现的位置应该位于web框架的中间件层。
首先是限流，限流要求在集群上实现限流，所以这里肯定是需要用到支持公共存储的组件比如redis。
这样每个实例在中间件里面都去请求redis查询和追加ip的请求次数即可。
熔断和降级在我的理解属于策略设计的一部分，中间件里需要设计策略，在什么情况下需要熔断和降级。
只要出发了熔断和降级的条件，那直接在中间件里把外部请求拒绝掉或者返回预定的数据即可。

> 为 userapp 提供 ORM  middleware，要求：慢查询监控。慢查询阈值可以通过后面的管理后台动态设置，并且实时生效

这个要求很容易实现，orm的demo中已经有了预设慢查询阈值的实现。需要追加管理后台动态设置的接口。
这个地方需要把慢查询阈值的属性提到orm的DB层面，因为orm对外服务最主要的就是DB，通用的配置放在这里是最合适的。
中间件直接从DB中获取慢查询阈值的设置。这样后期通过接口修改这个阈值的设置后，新的查询走到这里时拿到的就是新的值。

> 为 userapp 提供 ORM  middleware，要求：利用 middleware 来集成缓存，替换已有的缓存逻辑。触发降级之后，如果缓存之中没有数据，也不会去数据库查询数据（可选）
 
我看了一下现有的userapp，那里应该是采用写代码的方式，直接使用的缓存。
这种方式的坏处就是需要写代码，好处是用户可以完全控制缓存的走向。

如果要在中间件里面实现一个缓存，可以预见的会遇到几个问题：

第一：怎么存缓存，缓存的key怎么设计，因为orm不像普通的缓存，key其实应该是sql语句。
而且同一个语句，参数不一样的时候，命中的缓存应该也是不一样的。
如果用map来存储，那么这个key其实不怎么合理，哈希一下可能比较好。但是用了哈希，就免不了要解决碰撞的问题。

第二：数据不一致怎么办，这玩意是写在中间件里的，如果严格限制所有的对数据库访问都集中于几处那还好说，增删改的时候同时刷新一下数据。
但是是限制不了用户的数据库的操作的，用户有可能在任意一个地方，强行的操作数据库，那样他就有可能绕过中间件里的刷新逻辑。
如果在中间件里分析SQL语句的话，那复杂度又上去了，感觉有点得不偿失，不如让用户自己操作缓存。

当然不止这两个问题，但是我觉得这两个问题是最要紧要解决的。

> userapp 需要在启动的时候加载部分用户数据缓存起来。你可以固定写死 id < 1000 的就认为是热点用户
 
这个在框架初始化的时候，先加载好数据，最后在启动端口就好了。

> 利用 Gin 和 GORM 搭建一个简单的管理后台。userapp 在启动的时候会朝这个管理后台注册（近似于服务注册与发现的过程），后续用户可以通过管理后台设置前面熔断、限流、降级和慢查询的各种阈值。这个过程注意比较 Gin，GORM 框架和我们自己设计的框架之间的异同点
 
后台直接提供接口让 userapp 过来注册就好了，管理后台一般都是部署在内网的，直接开个注册接口问题不大。

> 管理后台和 userapp 之间必须保持心跳。如果 userapp 的一台实例下线了，那么管理后台将不会看到它（或者看到了它，但是它处于一种失活状态）

保持心跳这个和哨兵其实有点像，userapp 在启动的时候，去管理后台登记。
运行中，通过定时任务发送请求，上报一下自己的情况，下线的时候，可以在服务关闭的回调那里，通知管理后台自己下线了。

管理后台其实不需要做什么，只需要提供上报的接口，记录每个 userapp 最后一次上报的时间和数据就行了。
userapp 自己也可以提供探测接口，给管理后台使用。

如果管理后台设计了超时监测机制，就可以在超时之后主动地调用一下 userapp 的探测接口，获取本来应该由 userapp 上报的数据。
如果超过了预设的探测次数还没有得到响应，那就可以判断 userapp 下线了。
