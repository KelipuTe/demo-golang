因为demo这个项目并不是独立一个仓库，所以目录下的一些名字有点奇怪的文件是放在那里示意的。

### 工程结构

由于工作还是挺忙的，用gin大概搭了个项目的目录框架，整了个简单地接口。

```
cd demo_golang/go_homework/week04
go run cmd/blog-api/main.go
curl post 127.0.0.1:9501/api/v1/publish_article
```

工程结构差不多可以归类成，路由（api+中间件）、业务、数据（仓库+模型）

日常处理的项目，大部分是web服务，task服务，im服务（通信，通信，还是通信）。

好像不管是 go 项目还是 swoole 项目还是 php 项目，基本都是这套工程结构。

公司项目虽然是微服务化的，服务发现和服务注册之前用的 web service 那一套玩意。

基本就是流水线启动好之后去注册中心注册，服务关闭的时候先去注册中心注销，然后等一小会在关闭，然后重启。

后来，第一觉得之前的 web service 那一套注册中心不怎么好使（主要是和一个大流量的短视频的生活板块对接后，这玩意变成了热点），

第二觉得目前的规模也就20几个项目100多台机器，没必要加一层zookeeper。干脆直接改成了，负载均衡+流水线滚动发布的模式

用的阿里云+云效流水线（从负载踢掉，重启，再加回来），对于非极端情况的业务来说还是好使的。

### wire

wire 这玩意还是第一次用，作业里整了个简单的，用户+文档+发布事件，的捆绑逻辑。

之前就是毛老师说的那种直接手写的依赖注入，把一套复杂逻辑相关的数据模型，捆绑起来，做成门面设计模式的样子，然后new出来，方法挨个调。

其他的部分一般不用依赖注入，这种操作框架底层用的比较多。日常使用，大部分是注入接口实现。

不过后来这种注入接口实现，都被上下文+封装一个获取实例的方法，替代掉了。团队讨论后觉得，线性的流程比这种注入的方式更容易找也更容易理解。

只要获取实例的方法封装起来了，而且控制好数量，可维护性和可扩展性体感上差不多（当然，万一封装坑了，那用方法封装和依赖注入哪个都不好使）。
